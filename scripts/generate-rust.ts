// deno-lint-ignore-file no-explicit-any
import { basename, join } from "https://deno.land/std@0.208.0/path/mod.ts";

type JSONSchema = {
  title?: string;
  type?: string | string[];
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  additionalProperties?: boolean | JSONSchema;
  description?: string;
};

const DEFINITIONS_DIR = "./definitions";
const OUTPUT = "./rust/src/generated.rs";

function pascalCase(input: string): string {
  return input
    .replace(/[-_]+/g, " ")
    .replace(/\s+(\w)/g, (_, c) => c.toUpperCase())
    .replace(/^\w/, (c) => c.toUpperCase());
}

function rustTypeFromSchema(name: string, schema: JSONSchema, required: boolean, nested: Array<{ name: string; schema: JSONSchema }>): string {
  const inner = (() => {
    const t = schema.type;
    if (t === "string") return "String";
    if (t === "integer") return "i64";
    if (t === "number") return "f64";
    if (t === "boolean") return "bool";
    if (t === "array" && schema.items) {
      const itemType = rustTypeFromSchema(`${name}Item`, schema.items, true, nested).replace(/^Option<(.+)>$/, "$1");
      return `Vec<${itemType}>`;
    }
    if (t === "object") {
      if (schema.properties) {
        const nestedName = pascalCase(name);
        nested.push({ name: nestedName, schema });
        return nestedName;
      }
      return "std::collections::HashMap<String, serde_json::Value>";
    }
    return "serde_json::Value";
  })();
  return required ? inner : `Option<${inner}>`;
}

function buildStruct(name: string, schema: JSONSchema): { main: string; nested: string[] } {
  const nested: Array<{ name: string; schema: JSONSchema }> = [];
  const required = new Set(schema.required ?? []);
  const props = Object.entries(schema.properties ?? {}).map(([key, value]) => {
    const fieldRequired = required.has(key);
    const rustType = rustTypeFromSchema(`${name}${pascalCase(key)}`, value, fieldRequired, nested);
    const serdeLine = key.includes("_") ? `    #[serde(rename = "${key}")]` : undefined;
    const fieldName = key.replace(/-+/g, "_");
    const doc = value.description ? `    /// ${value.description}\n` : "";
    return `${doc}${serdeLine ? serdeLine + "\n" : ""}    pub ${fieldName}: ${rustType},`;
  });

  const nestedStructs = nested.map((n) => buildStruct(n.name, n.schema).main);

  const struct = `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ${name} {\n${props.join("\n")}\n}\n`;
  return { main: struct, nested: nestedStructs.flat() };
}

async function loadSchemas(): Promise<Array<{ name: string; schema: JSONSchema }>> {
  const result = [];
  for await (const entry of Deno.readDir(DEFINITIONS_DIR)) {
    if (!entry.isFile || !entry.name.endsWith(".json")) continue;
    const raw = await Deno.readTextFile(join(DEFINITIONS_DIR, entry.name));
    const schema = JSON.parse(raw) as JSONSchema;
    const name = pascalCase(schema.title ?? basename(entry.name, ".json"));
    result.push({ name, schema });
  }
  return result;
}

async function main() {
  const schemas = await loadSchemas();
  let output = "// AUTO-GENERATED. Do not edit directly.\n";
  output += "// Generated by scripts/generate-rust.ts\n\n";
  output += "use std::collections::HashMap;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n";

  for (const { name, schema } of schemas) {
    const { main, nested } = buildStruct(name, schema);
    output += nested.join("\n") + (nested.length ? "\n" : "");
    output += main + "\n";
  }

  await Deno.mkdir("./rust/src", { recursive: true });
  await Deno.writeTextFile(OUTPUT, output);
  console.log(`âœ“ Generated ${OUTPUT}`);
}

await main();
