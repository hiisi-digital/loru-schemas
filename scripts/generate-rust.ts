import {
  type JSONSchema,
  loadSchemas,
  normalizeRef,
  pascalCase,
  resolveSchema,
} from "./schema_utils.ts";

const OUTPUT = "./rust/src/generated.rs";

function rustTypeFromSchema(
  name: string,
  schema: JSONSchema,
  required: boolean,
  nested: Array<{ name: string; schema: JSONSchema }>,
  defs: Record<string, JSONSchema>,
): string {
  if (schema.$ref) {
    const refName = normalizeRef(schema.$ref);
    if (refName) return pascalCase(refName);
  }
  const normalized = resolveSchema(schema, defs);
  const inner = (() => {
    const t = normalized.type;
    if (normalized.enum?.length) {
      return "String";
    }
    if (t === "string") return "String";
    if (t === "integer") return "i64";
    if (t === "number") return "f64";
    if (t === "boolean") return "bool";
    if (t === "array" && normalized.items) {
      const itemType = rustTypeFromSchema(
        `${name}Item`,
        normalized.items,
        true,
        nested,
        defs,
      ).replace(/^Option<(.+)>$/, "$1");
      return `Vec<${itemType}>`;
    }
    if (t === "object") {
      if (normalized.properties) {
        const nestedName = pascalCase(name);
        nested.push({ name: nestedName, schema: normalized });
        return nestedName;
      }
      return "std::collections::HashMap<String, serde_json::Value>";
    }
    return "serde_json::Value";
  })();
  return required ? inner : `Option<${inner}>`;
}

function buildStruct(
  name: string,
  schema: JSONSchema,
): { main: string; nested: string[] } {
  const defs = schema.$defs ?? {};
  const normalized = resolveSchema(schema, defs);
  const nested: Array<{ name: string; schema: JSONSchema }> = [];
  const required = new Set(normalized.required ?? []);
  const props = Object.entries(normalized.properties ?? {}).map(
    ([key, value]) => {
      const fieldRequired = required.has(key);
      const rustType = rustTypeFromSchema(
        `${name}${pascalCase(key)}`,
        value,
        fieldRequired,
        nested,
        defs,
      );
      const serdeLine = key.includes("_")
        ? `    #[serde(rename = "${key}")]`
        : undefined;
      const fieldName = key.replace(/-+/g, "_");
      const doc = value.description ? `    /// ${value.description}\n` : "";
      return `${doc}${
        serdeLine ? serdeLine + "\n" : ""
      }    pub ${fieldName}: ${rustType},`;
    },
  );

  const nestedStructs = nested.flatMap((n) => {
    const built = buildStruct(n.name, n.schema);
    return [...built.nested, built.main];
  });

  const struct =
    `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ${name} {\n${
      props.join("\n")
    }\n}\n`;
  return { main: struct, nested: nestedStructs };
}

async function main() {
  const schemas = await loadSchemas();
  let output = "// AUTO-GENERATED. Do not edit directly.\n";
  output += "// Generated by scripts/generate-rust.ts\n\n";
  output += "use std::collections::HashMap;\nuse serde_json::Value;\n\n";

  const names = new Set<string>(schemas.map((s) => s.name));

  for (const { name, schema, defs } of schemas) {
    const withDefs = { ...schema, $defs: defs };
    const { main, nested } = buildStruct(name, withDefs);
    output += nested.join("\n") + (nested.length ? "\n" : "");
    output += main + "\n";
  }

  if (names.has("PipelineStepBase")) {
    output += `pub trait PipelineStep {\n`;
    output += `    fn name(&self) -> Option<&String>;\n`;
    output += `    fn targets(&self) -> Option<&Vec<String>>;\n`;
    output += `    fn cmd(&self) -> Option<&String>;\n`;
    output += `    fn platform(&self) -> Option<&HashMap<String, Value>>;\n`;
    output += `}\n\n`;

    const impls = ["PipelineStepBase", "CheckTask", "BuildTask"];
    for (const typ of impls) {
      if (!names.has(typ)) continue;
      output += `impl PipelineStep for ${typ} {\n`;
      output +=
        `    fn name(&self) -> Option<&String> { self.name.as_ref() }\n`;
      output +=
        `    fn targets(&self) -> Option<&Vec<String>> { self.targets.as_ref() }\n`;
      output += `    fn cmd(&self) -> Option<&String> { self.cmd.as_ref() }\n`;
      output +=
        `    fn platform(&self) -> Option<&HashMap<String, Value>> { self.platform.as_ref() }\n`;
      output += `}\n\n`;
    }
  }

  await Deno.mkdir("./rust/src", { recursive: true });
  await Deno.writeTextFile(OUTPUT, output);
  console.log(`âœ“ Generated ${OUTPUT}`);
}

await main();
