// deno-lint-ignore-file no-explicit-any
import { normalizeRef, resolveSchema, pascalCase, loadSchemas, type JSONSchema } from "./schema_utils.ts";

const OUTPUT = "./typescript/mod.ts";

function tsTypeFromSchema(
  name: string,
  schema: JSONSchema,
  required: boolean,
  nested: Array<{ name: string; schema: JSONSchema }>,
  defs: Record<string, JSONSchema>,
): string {
  if (schema.$ref) {
    const refName = normalizeRef(schema.$ref);
    if (refName) return `${pascalCase(refName)}${required ? "" : " | undefined"}`;
  }
  const normalized = resolveSchema(schema, defs);
  const optional = required ? "" : " | undefined";
  const type = (() => {
    const t = normalized.type;
    if (normalized.enum?.length) {
      return normalized.enum.map((v) => JSON.stringify(v)).join(" | ");
    }
    if (t === "string") return "string";
    if (t === "integer" || t === "number") return "number";
    if (t === "boolean") return "boolean";
    if (t === "array" && normalized.items) {
      const itemType = tsTypeFromSchema(`${name}Item`, normalized.items, true, nested, defs).replace(" | undefined", "");
      return `${itemType}[]`;
    }
    if (t === "object") {
      if (normalized.properties) {
        const nestedName = pascalCase(`${name}`);
        nested.push({ name: nestedName, schema: normalized });
        return nestedName;
      }
      return "Record<string, unknown>";
    }
    return "unknown";
  })();
  return `${type}${optional}`;
}

function collectExtends(schema: JSONSchema): string[] {
  const bases: string[] = [];
  if (schema.$ref) {
    const ref = normalizeRef(schema.$ref);
    if (ref) bases.push(pascalCase(ref));
  }
  if (schema.allOf) {
    for (const part of schema.allOf) {
      if (part.$ref) {
        const ref = normalizeRef(part.$ref);
        if (ref) bases.push(pascalCase(ref));
      }
    }
  }
  return bases;
}

function buildInterface(name: string, schema: JSONSchema, defs: Record<string, JSONSchema>): { main: string; nested: string[] } {
  const normalized = resolveSchema(schema, defs);
  const nested: Array<{ name: string; schema: JSONSchema }> = [];
  const required = new Set(normalized.required ?? []);
  const props = Object.entries(normalized.properties ?? {}).map(([key, value]) => {
    const fieldRequired = required.has(key);
    const type = tsTypeFromSchema(`${name}${pascalCase(key)}`, value, fieldRequired, nested, defs);
    const optional = fieldRequired ? "" : "?";
    const desc = value.description ? `  // ${value.description}` : "";
    return `  ${key}${optional}: ${type};${desc ? "\n" + desc : ""}`;
  });

  const nestedInterfaces = nested.flatMap((n) => {
    const built = buildInterface(n.name, n.schema, defs);
    return [...built.nested, built.main];
  });

  const extendsList = collectExtends(schema);
  const iface = `export interface ${name}${extendsList.length ? ` extends ${extendsList.join(", ")}` : ""} {\n${props.join("\n")}\n}\n`;
  return { main: iface, nested: nestedInterfaces };
}

async function main() {
  const schemas = await loadSchemas();
  let output = "// AUTO-GENERATED. Do not edit directly.\n";
  output += "// Generated by scripts/generate-ts.ts\n\n";

  for (const { name, schema, defs } of schemas) {
    const { main, nested } = buildInterface(name, schema, defs);
    output += nested.join("\n") + (nested.length ? "\n" : "");
    output += main + "\n";
  }

  await Deno.mkdir("./typescript", { recursive: true });
  await Deno.writeTextFile(OUTPUT, output);
  console.log(`âœ“ Generated ${OUTPUT}`);
}

await main();
