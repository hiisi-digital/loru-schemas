// deno-lint-ignore-file no-explicit-any
import { basename, join } from "https://deno.land/std@0.208.0/path/mod.ts";

type JSONSchema = {
  title?: string;
  type?: string | string[];
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  additionalProperties?: boolean | JSONSchema;
  description?: string;
  pattern?: string;
};

const DEFINITIONS_DIR = "./definitions";
const OUTPUT = "./typescript/mod.ts";

function pascalCase(input: string): string {
  return input
    .replace(/[-_]+/g, " ")
    .replace(/\s+(\w)/g, (_, c) => c.toUpperCase())
    .replace(/^\w/, (c) => c.toUpperCase());
}

function tsTypeFromSchema(name: string, schema: JSONSchema, required: boolean, nested: Array<{ name: string; schema: JSONSchema }>): string {
  const optional = required ? "" : " | undefined";
  const type = (() => {
    const t = schema.type;
    if (t === "string") return "string";
    if (t === "integer" || t === "number") return "number";
    if (t === "boolean") return "boolean";
    if (t === "array" && schema.items) {
      const itemType = tsTypeFromSchema(`${name}Item`, schema.items, true, nested).replace(" | undefined", "");
      return `${itemType}[]`;
    }
    if (t === "object") {
      if (schema.properties) {
        const nestedName = pascalCase(`${name}`);
        nested.push({ name: nestedName, schema });
        return nestedName;
      }
      return "Record<string, unknown>";
    }
    return "unknown";
  })();
  return `${type}${optional}`;
}

function buildInterface(name: string, schema: JSONSchema): { main: string; nested: string[] } {
  const nested: Array<{ name: string; schema: JSONSchema }> = [];
  const required = new Set(schema.required ?? []);
  const props = Object.entries(schema.properties ?? {}).map(([key, value]) => {
    const fieldRequired = required.has(key);
    const type = tsTypeFromSchema(`${name}${pascalCase(key)}`, value, fieldRequired, nested);
    const optional = fieldRequired ? "" : "?";
    const desc = value.description ? `  // ${value.description}` : "";
    return `  ${key}${optional}: ${type};${desc ? "\n" + desc : ""}`;
  });

  const nestedInterfaces = nested.map((n) => buildInterface(n.name, n.schema).main);

  const iface = `export interface ${name} {\n${props.join("\n")}\n}\n`;
  return { main: iface, nested: nestedInterfaces.flat() };
}

async function loadSchemas(): Promise<Array<{ name: string; schema: JSONSchema }>> {
  const result = [];
  for await (const entry of Deno.readDir(DEFINITIONS_DIR)) {
    if (!entry.isFile || !entry.name.endsWith(".json")) continue;
    const raw = await Deno.readTextFile(join(DEFINITIONS_DIR, entry.name));
    const schema = JSON.parse(raw) as JSONSchema;
    const name = pascalCase(schema.title ?? basename(entry.name, ".json"));
    result.push({ name, schema });
  }
  return result;
}

async function main() {
  const schemas = await loadSchemas();
  let output = "// AUTO-GENERATED. Do not edit directly.\n";
  output += "// Generated by scripts/generate-ts.ts\n\n";

  for (const { name, schema } of schemas) {
    const { main, nested } = buildInterface(name, schema);
    output += nested.join("\n") + (nested.length ? "\n" : "");
    output += main + "\n";
  }

  await Deno.mkdir("./typescript", { recursive: true });
  await Deno.writeTextFile(OUTPUT, output);
  console.log(`âœ“ Generated ${OUTPUT}`);
}

await main();
